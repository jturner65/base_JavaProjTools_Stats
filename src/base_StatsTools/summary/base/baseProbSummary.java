package base_StatsTools.summary.base;

import java.util.TreeMap;

import base_Math_Objects.MyMathUtils;

/**
 * abstract class to provide the backbone for analysis of data sets
 * @author john
 *
 */
public abstract class baseProbSummary {

	/**
	 * # of values being summarized
	 */
	protected int numVals;
	//flags holding state information about this summary object
	//state flags - bits in array holding relevant info about this random variable function
	private int[] stFlags;						
	public static final int 
	//these idxs need to correspond to idxs in mmnts array of each value
		meanIDX				= 0, 
		stdIDX				= 1, 
		skewIDX				= 2,
		kurtIDX				= 3,
		//insert any higher moments in here
		//these are convenience calcs/transforms of base moment values
		varIDX				= 4,
		excKurtIDX			= 5,
		//
		setByDataIDX		= 6,				//whether the moments values in this object were set by data or were set specifically
		smplValsCalcedIDX 	= 7,				//sample moments calculated for a specific sample size
		clipAllSmplsIDX		= 8;				//all samples should be clipped to given min/max values
	//# of boolean flags
	public static final int numFlags = 9;
	//# of samples, if sample size set
	protected int sampleSize;
	//# of moments actually specified, not counting derived moments
	public int numMmntsGiven;
	//label describing every moment
	public static final String[] mmntLabels = new String[] {"Mean","STD","Skew","Kurtosis", "Variance","Excess Kurtosis"};
	//# of moments being tracked, including duped moments - idx doesn't correspond necessarily to moment order
	public static final int numTrackedMmnts = mmntLabels.length;
	protected final String frmtStr = "% 10.2f";


	public baseProbSummary() {
		initFlags();		
	}
		
	//whether all samples generated by the function utilizing this summary should be clipped
	public boolean doClipAllSamples() {return getFlag(clipAllSmplsIDX);}
	public void setClipAllSamples(boolean val) {setFlag(clipAllSmplsIDX, val);}
	
	
	/**
	 * return the value 0->1 corresponding to the scaled location between min and max
	 * @param val
	 * @param min
	 * @param max
	 * @return
	 */
	protected final float scaleVal(float val, float min, float max) {
		if(Math.abs(max-min) < MyMathUtils.EPS_F) {return 0.0f;}		
		return (val-min)/(max-min);		
	}
	
	
	/**
	 * return the value 0->1 corresponding to the scaled location between min and max
	 * @param val
	 * @param min
	 * @param max
	 * @return
	 */
	protected final double scaleVal(double val, double min, double max) {
		if(Math.abs(max-min) < MyMathUtils.EPS) {return 0.0;}
		return (val-min)/(max-min);			
	}
	
	/**
	 * provide a summary of stats for the data this summary object manages
	 * @param smryName
	 * @return
	 */
	public abstract TreeMap<String,String> summaryStringAra(String smryName);
	
	protected void initFlags(){stFlags = new int[1 + numFlags/32]; for(int i = 0; i<numFlags; ++i){setFlag(i,false);}}
	public void setAllFlags(int[] idxs, boolean val) {for (int idx : idxs) {setFlag(idx, val);}}
	public void setFlag(int idx, boolean val){
		int flIDX = idx/32, mask = 1<<(idx%32);
		stFlags[flIDX] = (val ?  stFlags[flIDX] | mask : stFlags[flIDX] & ~mask);
		switch (idx) {//special actions for each flag
			case meanIDX	 		: {break;} 
			case stdIDX		 		: {break;} 
			case skewIDX			: {break;} 
			case kurtIDX			: {break;} 						
			case varIDX		 		: {break;} 
			case excKurtIDX			: {break;}
			case setByDataIDX		: {break;}
			case smplValsCalcedIDX	: {break;}			//whether multipliers to modify calculated pop moments to be appropriate sample moments have been calculated
			case clipAllSmplsIDX 	: {break;}
		}
	}//setFlag		
	public boolean getFlag(int idx){int bitLoc = 1<<(idx%32);return (stFlags[idx/32] & bitLoc) == bitLoc;}		


}//abstract class baseProbSummary 
